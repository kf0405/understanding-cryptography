# Problems

1.  
    1. $e_k = y_i \equiv x_i + s_i mod 26$ and $d_k = x_i \equiv y_i - s_i mod 26$. The key stream can just be letters themselves, which will be transformed into numbers.
    2. Kaspar Hauser
    3. He was stabbed in the chest  

2.  
    1. Life cycle of key: the key can only be used for the transfer of 1Gbyte, storage of key during life cycle: the DVD must be protected from access from unauthorized access, after life cycle: key shouldn't be used after the 1Gbyte, as it becomes obsolete and loses its One time key purpose, key distribution: should be distributed securely by a trusted courier, key generation: must be generated by a true random number generator source, such as white noise.  

3.  
    1. If the key is used repeatedly, instead of just one time, as is its purpose, the attacker could simply intercept two ciphertexts and, as both share a key K, they would both involve a XOR'ing of the plaintext with the same key K. That means the attacker could derive the messages after finding the key through a system.

4.  
    1. An exhaustive key search will not work, as if we were to try all possible $2^40$ plaintexts derived from all $2^40$ possible keys, all results would be equally likely to be the real answer - there is no way to know which would be the correct one, and considering the enormous key-space, by trying to decrypt a word in english, we might find all other possible words with the same size.

5.  
    1. The plaintext: 4c 65 74 73 45 6e 63 72 79 70 74 54 68 69 73 42 6f 6f 6b = LetsEncryptThisBook  

6.  
    1. Two major drawbacks: requires a different key bit for every bit of the original message and the key should only be known to legitimate communication parties, so we can't send it through the Internet, we would need some other form of transportation for the key.

7.  
    1. 1 1 0
    2. 0 0 1
    3. One is the inverse of the other  

8. 
    1. One could try to detect the period by trying the same plaintext many times, or plaintexts with different sizes to see what changes. Trying to guess the result of XORs with specific, common ASCII characters could also be done(like the letter 'A'). As the key space is small, brute force is also an option. 

9.  
    1. 0 0 0 0 1 0 1 1 1 1 0 0 0 1 0 0

10.  
    1. Max length = 15 bits ($2^{m}-1$). 1 and 2 are primitive, so they generate 15 bit sequences. 3 is not. Calculating all sequences for one polynomial should be enough:  
    0001 → 000111010011100 | 0001...
    0010 → 001110100111000  
    0011 → 001110100111000  
    0100 → 011101001110000  
    0101 → 011010011101000  
    0110 → 011001111010001  
    0111 → 011110100111000  
    1000 → 111010011100010  
    1001 → 110100111000101  
    1010 → 101001110001011  
    1011 → 101110100111000  
    1100 → 110100111000101  
    1101 → 111010011100010  
    1110 → 111001111010001  
    1111 → 111110101001110  
    3. As 3 is non primitive it should have a shorter sequence:  
    0001 → 0001100011(length 5)

11. 
    1. In the worst case, we need 2 times the length, as we need to have two full sequences to determine the key through a system with 2 equations of ciphertext, plaintext and key.
    2. Keystream bit = ciphertext bit XOR plaintext bit. The 2 equations would be $K_{256}=Y_{256} \oplus X_{256}$ and $K_{512}=Y_{512} \oplus X_{512}$, with the first one being the first 256 bits and the second one the second sequence of 256 bits.
    3. The key is the sequence of 256 bits of maximum length. The initial elements should not be the key, as LSRFs are linear, so attackers can reconstruct the initial state and it can be recovered from the keystream.

12. 
    1. The degree is 13.
    2. 00101110010111
    3. 1 + x + x3 + x4 + x7 + x10 + x11 + x13
    4. -

13. 
    1. First, we convert WPI and the ciphered message to binary. Now, we can obtain the form encrypted WPI will have in the keystream by XOR'ing it with the first 3 letters from the cipher code (as they will have the same length). With that we get our IV, the first 6 bits, as our m is 6. The result is 111111 (We consider the IV starts with W).
    2. 1 + x5 + x6
    3. WIPWOMBAT
    4. Australia
    5. Known plaintext, as we knew the WPI header was a part of the result.

14. 
    1.  With the known plaintext, the attacker can make a system of 3 equations with the equations for all the $z_{i}$ up to 3. With this system, we can subtract z3 for z2, and that way we will find a or b. With one of them, we can find the other. At the end, the only remaining element will be the seed, so we can just replace a and b on $z_{1}$ to find the results. a = 15 b = 164 $z_{0}$ = 55.
    2. This is a known plaintext attack. Knowing enough pairs of plaintext and ciphertext, and also the LCG (linear congruing generator).  

15.  
    1. We use the same logic as the problem before, but this time we will have to find a, b and c. a = 225, b = 246, c = 174.

16. 
    1. The Salsa20 initial state Matrix would therefore feature all zeros for the exception of the constant bits, that should be "expand 32-byte k"  
    [ 0x61707865, 0x00000000, 0x00000000, 0x00000000 ]  
    [ 0x00000000, 0x3320646e, 0x00000000, 0x00000000 ]  
    [ 0x00000000, 0x00000000, 0x79622d32, 0x00000000 ]  
    [ 0x00000000, 0x00000000, 0x00000000, 0x6b206574 ]

17. 
    1. a = 0x10000001, b = 0x80808808, c = 0x01010110, d = 0x01000110

18.  
    1. At the beginning, only one bit would be 1, the bit 110. Using the code on 2-18.py, we get the first 70 warm-up bits:  
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0].